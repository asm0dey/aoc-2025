<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 3 Visualization: Max Joltage</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --panel-bg: #252526;
            --accent: #4caf50;
            --highlight: #61afef;
            --selected: #98c379;
            --discarded: #e06c75;
            --inactive: #5c6370;
            --cell-bg: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 350px;
            background-color: var(--panel-bg);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 1px solid #333;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
            overflow-y: auto;
        }

        h2 { margin-top: 0; font-size: 1.2rem; color: var(--accent); }
        label { font-size: 0.9rem; color: #aaa; display: block; margin-bottom: 5px; }

        textarea {
            width: 100%;
            height: 100px;
            background-color: #111;
            border: 1px solid #444;
            color: #ddd;
            font-family: monospace;
            resize: vertical;
            padding: 5px;
            box-sizing: border-box;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px;
            background-color: #111;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 4px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .stat-val { font-weight: bold; font-family: monospace; }
        .result-val { color: var(--accent); font-size: 1.1em; }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn-primary { background-color: var(--accent); color: white; }
        .btn-primary:hover { background-color: #43a047; }
        .btn-primary:disabled { background-color: #2e3b2e; cursor: not-allowed; color: #888; }

        .btn-secondary { background-color: #444; color: white; }
        .btn-secondary:hover { background-color: #555; }

        .btn-danger { background-color: var(--discarded); color: white; }
        .btn-danger:hover { background-color: #d32f2f; }

        /* Main Visualization Area */
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            align-items: center;
            justify-content: flex-start;
            overflow-y: auto;
        }

        .tape-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            max-width: 90%;
            margin-top: 50px;
        }

        .digit-cell {
            width: 30px;
            height: 40px;
            background-color: var(--cell-bg);
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 4px;
            /* Smoother, specific transitions */
            transition: background-color 0.2s ease,
                        color 0.2s ease,
                        transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), /* Bouncy pop */
                        border-color 0.2s ease,
                        opacity 0.2s ease;
            position: relative;
            will-change: transform, background-color;
        }

        /* States */
        .in-window {
            border-color: var(--highlight);
            background-color: rgba(97, 175, 239, 0.15);
            box-shadow: 0 0 10px rgba(97, 175, 239, 0.1);
        }
        
        .selected {
            background-color: var(--selected);
            color: #111;
            transform: scale(1.25); /* Larger pop */
            z-index: 10;
            border-color: #fff;
            box-shadow: 0 0 20px var(--selected);
        }

        .discarded {
            background-color: #161616;
            color: #333; 
            border-color: transparent;
            transform: scale(0.85); /* Shrink away */
            opacity: 0.7;
        }

        .future {
            color: #666;
            background-color: #222;
        }

        .current-result-display {
            margin-top: 30px;
            font-size: 2rem;
            font-family: monospace;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            font-size: 0.8rem;
            color: #aaa;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 12px; height: 12px; border-radius: 2px; }

    </style>
</head>
<body>

<div class="sidebar">
    <h2>Configuration</h2>

    <div>
        <label for="inputData">Input Digits (Lines)</label>
        <textarea id="inputData" placeholder="Paste input...">
62339877936615968625526596861627151491231795557618166257714599847162925385253855
        </textarea>
    </div>

    <div>
        <label for="stepCount">Steps to Make (Part 2 default: 12)</label>
        <input type="number" id="stepCount" value="12" min="1">
    </div>

    <button class="btn-secondary" onclick="loadAll()">Load Data</button>

    <hr style="border-color: #333; width: 100%;">

    <h2>Visualization Control</h2>

    <div>
        <label for="lineIndex">Select Line</label>
        <div style="display:flex; gap:5px;">
            <button class="btn-secondary" style="flex:1" onclick="changeLine(-1)">◀</button>
            <input type="number" id="lineIndex" value="0" min="0" style="flex:1; text-align:center;" onchange="loadLineVisualization()">
            <button class="btn-secondary" style="flex:1" onclick="changeLine(1)">▶</button>
        </div>
    </div>

    <div class="stats-panel">
        <div class="stat-row"><span>Steps Remaining:</span> <span id="uiStepsRem" class="stat-val">-</span></div>
        <div class="stat-row"><span>Current Value:</span> <span id="uiCurrentVal" class="stat-val">-</span></div>
    </div>

    <div class="controls">
        <button class="btn-primary" id="btnStep" onclick="step()" disabled>Step</button>
        <button class="btn-primary" id="btnRun" onclick="toggleAuto()" disabled>Run All</button>
        <button class="btn-danger" onclick="resetViz()">Reset</button>
    </div>

    <hr style="border-color: #333; width: 100%;">

    <div class="stats-panel">
        <div class="stat-row"><span>Line Result:</span> <span id="lineResult" class="stat-val">-</span></div>
        <div class="stat-row"><span>Total Sum (All Lines):</span> <span id="totalSum" class="stat-val result-val">-</span></div>
    </div>
</div>

<div class="main-content">
    <div class="current-result-display" id="bigResultDisplay"></div>
    <div class="tape-container" id="tapeContainer"></div>

    <div class="legend">
        <div class="legend-item"><div class="dot" style="background:var(--highlight)"></div> Search Window</div>
        <div class="legend-item"><div class="dot" style="background:var(--selected)"></div> Selected (Max)</div>
        <div class="legend-item"><div class="dot" style="background:var(--discarded)"></div> Used/Discarded</div>
        <div class="legend-item"><div class="dot" style="background:#222; border:1px solid #333;"></div> Unprocessed</div>
    </div>
</div>

<script>
    // --- Logic (Mirroring Kotlin but preserving global indices) ---

    function solveSingleLine(originalInputArray, steps) {
        let currentInput = [...originalInputArray]; // Mirroring the mutable list part logic
        let stepsRemaining = steps;
        let resultStr = "";
        let history = [];
        let globalOffset = 0; // Tracks the start of 'currentInput' relative to 'originalInputArray'

        // Record initial state
        history.push({
            type: 'start',
            globalOffset: 0,
            stepsRemaining: stepsRemaining,
            currentResult: resultStr
        });

        while (stepsRemaining > 0) {
            // The algorithm must leave (stepsRemaining - 1) elements.
            // Max index we can look at is: length - stepsRemaining
            const searchLimitIndex = currentInput.length - stepsRemaining;

            // Find max in range [0, searchLimitIndex]
            let maxVal = -1;
            let bestIndex = -1;

            for (let i = 0; i <= searchLimitIndex; i++) {
                if (currentInput[i] > maxVal) {
                    maxVal = currentInput[i];
                    bestIndex = i;
                }
            }

            // Map local indices to global for visualization
            const globalBestIndex = globalOffset + bestIndex;
            const globalWindowEnd = globalOffset + searchLimitIndex;

            // Record step state BEFORE modification (Selection Phase)
            history.push({
                type: 'selection',
                globalOffset: globalOffset,
                windowEnd: globalWindowEnd,
                bestIndex: globalBestIndex,
                maxVal: maxVal,
                stepsRemaining: stepsRemaining,
                currentResult: resultStr
            });

            // Update Result
            resultStr += maxVal;

            // Cut logic: discard everything up to and including bestIndex
            // In Kotlin: subList(firstBestIndex + 1, input.size)
            const cutSize = bestIndex + 1;
            currentInput = currentInput.slice(cutSize);
            globalOffset += cutSize;
            stepsRemaining--;

            // Record state AFTER cut (Stable Phase)
            history.push({
                type: 'cut',
                globalOffset: globalOffset,
                stepsRemaining: stepsRemaining,
                currentResult: resultStr
            });
        }

        history.push({
            type: 'finished',
            globalOffset: originalInputArray.length, // Everything consumed effectively
            finalResult: resultStr
        });

        return { result: resultStr, history: history };
    }

    // --- App State ---
    let allLines = [];
    let currentLineIndex = 0;
    let currentStepsConfig = 12;

    let currentOriginalDigits = []; // Store current line digits
    let vizHistory = [];
    let vizStepIndex = 0;
    let isRunning = false;
    let autoTimer = null;

    // --- Initialization ---

    function loadAll() {
        const text = document.getElementById('inputData').value.trim();
        if(!text) return;

        allLines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        currentStepsConfig = parseInt(document.getElementById('stepCount').value) || 12;

        // Calculate Total Sum (Quick Pre-calculation)
        let total = BigInt(0);
        allLines.forEach(lineStr => {
            const digits = lineStr.split('').map(Number);
            const res = solveSingleLine(digits, currentStepsConfig).result;
            if(res) total += BigInt(res);
        });

        document.getElementById('totalSum').textContent = total.toString();
        document.getElementById('lineIndex').max = allLines.length - 1;

        // Reset to first line
        document.getElementById('lineIndex').value = 0;
        loadLineVisualization();
    }

    function changeLine(delta) {
        const input = document.getElementById('lineIndex');
        let val = parseInt(input.value) + delta;
        if (val >= 0 && val < allLines.length) {
            input.value = val;
            loadLineVisualization();
        }
    }

    function loadLineVisualization() {
        currentLineIndex = parseInt(document.getElementById('lineIndex').value);
        if (currentLineIndex >= allLines.length) return;

        const lineStr = allLines[currentLineIndex];
        currentOriginalDigits = lineStr.split('').map(Number);

        const solution = solveSingleLine(currentOriginalDigits, currentStepsConfig);
        vizHistory = solution.history;
        
        document.getElementById('lineResult').textContent = solution.result;
        
        // REMOVED: document.getElementById('tapeContainer').innerHTML = ''; 
        // We now handle content updates gracefully in renderStep
        
        // Reset Viz
        vizStepIndex = 0;
        // Don't stop auto here if we are chaining lines
        // stopAuto(); 
        renderStep(0);
        
        document.getElementById('btnStep').disabled = false;
        document.getElementById('btnRun').disabled = false;
    }

    function resetViz() {
        vizStepIndex = 0;
        stopAuto();
        renderStep(0);
    }

    // --- Rendering ---

    function renderStep(index) {
        const state = vizHistory[index];
        const container = document.getElementById('tapeContainer');
        const resultDisp = document.getElementById('bigResultDisplay');
        const uiSteps = document.getElementById('uiStepsRem');
        const uiVal = document.getElementById('uiCurrentVal');

        // Smart DOM Update: Only rebuild if length changes. Otherwise reuse elements.
        if(container.children.length !== currentOriginalDigits.length) {
             container.innerHTML = '';
             currentOriginalDigits.forEach((digit, i) => {
                const cell = document.createElement('div');
                cell.className = 'digit-cell';
                cell.textContent = digit;
                cell.id = `cell-${i}`;
                container.appendChild(cell);
            });
        } else {
            // Update numbers in existing cells if they differ (fixes stale numbers issue without blinking)
            for(let i=0; i<currentOriginalDigits.length; i++) {
                const cell = container.children[i];
                // Use loose inequality to handle number vs string comparison efficiently
                if(cell.textContent != currentOriginalDigits[i]) {
                    cell.textContent = currentOriginalDigits[i];
                }
            }
        }

        if (!state) return;

        // Update Stats
        resultDisp.textContent = state.currentResult || (state.finalResult || "");
        uiSteps.textContent = state.stepsRemaining !== undefined ? state.stepsRemaining : 0;
        uiVal.textContent = state.maxVal !== undefined ? state.maxVal : "-";

        // Apply classes to existing cells
        // We use a requestAnimationFrame to batch style updates if needed, but direct update is fine here
        currentOriginalDigits.forEach((_, i) => {
            const cell = document.getElementById(`cell-${i}`);
            // Reset base class (keeping transitions)
            let newClass = 'digit-cell';

            if (i < state.globalOffset) {
                newClass += ' discarded';
            } else {
                if (state.type === 'selection') {
                    if (i <= state.windowEnd) {
                        newClass += ' in-window';
                    } else {
                        newClass += ' future';
                    }

                    if (i === state.bestIndex) {
                        newClass += ' selected';
                    }
                } else if (state.type === 'cut') {
                    newClass += ' future';
                } else if (state.type === 'finished') {
                    newClass += ' discarded';
                } else {
                    newClass += ' future';
                }
            }
            
            // Only change className if different to prevent transition interrupts/recalc
            if(cell.className !== newClass) {
                cell.className = newClass;
            }
        });

        // Auto-scroll to keep action in view
        if(isRunning && (state.type === 'selection' || state.type === 'cut')) {
            const focusIndex = state.globalOffset;
            const cell = document.getElementById(`cell-${focusIndex}`);
            if (cell) {
                // Smooth scroll to center
                cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }

    // --- Loop Control ---

    function step() {
        // If current line finished
        if (vizStepIndex >= vizHistory.length - 1) {
            // Check if we can move to next line
            if (currentLineIndex < allLines.length - 1) {
                // Move to next line
                const nextIdx = currentLineIndex + 1;
                document.getElementById('lineIndex').value = nextIdx;
                loadLineVisualization();
                // loadLineVisualization resets vizStepIndex to 0
                return true; // Continued
            } else {
                // Totally done
                stopAuto();
                return false; // Stopped
            }
        } else {
            vizStepIndex++;
            renderStep(vizStepIndex);
            return true; // Continued
        }
    }

    function toggleAuto() {
        if (isRunning) {
            stopAuto();
        } else {
            isRunning = true;
            document.getElementById('btnRun').textContent = "Stop";
            document.getElementById('btnRun').classList.add('btn-danger');
            document.getElementById('btnRun').classList.remove('btn-primary');

            // Fast speed: 50ms
            autoTimer = setInterval(() => {
                const keepGoing = step();
                if(!keepGoing) stopAuto();
            }, 100);
        }
    }

    function stopAuto() {
        isRunning = false;
        if (autoTimer) clearInterval(autoTimer);
        const btn = document.getElementById('btnRun');
        btn.textContent = "Run All";
        btn.classList.remove('btn-danger');
        btn.classList.add('btn-primary');
    }

    // Initial Load
    window.onload = () => {
        loadAll();
    };

</script>

</body>
</html>